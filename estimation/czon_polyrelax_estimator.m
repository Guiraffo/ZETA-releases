function [Xnew,cputimes] = czon_polyrelax_estimator(dtsys,X_prev,W,V,u,y,OPTIONS)
%CZON_POLYRELAX_ESTIMATOR implements the state estimation method based on
%                         constrained zonotopes and polyhedral relaxations

% (C) Copyright 2025 ZETA Developers
%
% This file is a part of the ZETA toolbox
%
%     ZETA is free software: you can redistribute it and/or modify
%     it under the terms of the GNU Lesser General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     ZETA is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU Lesser General Public License for more details.
%
%     You should have received a copy of the GNU Lesser General Public License
%     along with ZETA.  If not, see <http://www.gnu.org/licenses/>.
%
% ZETA on github: https://github.com/Guiraffo/ZETA-releases
%
% Corresponding author: Brenner Santana Rego, brennersr7@usp.br

% Clear and initialize the static variables hrep, z, and elimind
Polyrelax.clear;

% Setup algorithm flags based on input string
flags.pred = any(OPTIONS.alg=='p');
flags.updt = any(OPTIONS.alg=='u');

tic;
% Initialize Polyrelax objects for the state variables
Xhull = intervalhull(X_prev);
nx = dtsys.nx;
Xpolyrel = Polyrelax.empty(0,1);
for j=1:nx
    Xpolyrel(j,1) = Polyrelax(Xhull(j));
end

% If prediction step will be performed, initialize process disturbance objects
nw = dtsys.nw;
if(flags.pred)
    if(nw==0)
        Wpolyrel = [];
        W = CZonotope;
    else
        Whull = intervalhull(W);
        Wpolyrel = Polyrelax.empty(0,1);
        for j=1:nw
            Wpolyrel(j,1) = Polyrelax(Whull(j));
        end
    end
else
    W = CZonotope;
end

% If update step will be performed, initialize measurement disturbance objects
nv = dtsys.nv;
if(flags.updt)
    if(nv==0)
        Vpolyrel = [];
        V = CZonotope;
    else
        Vhull = intervalhull(V);
        Vpolyrel = Polyrelax.empty(0,1);
        for j=1:nv
            Vpolyrel(j,1) = Polyrelax(Vhull(j));
        end
    end
else
    V = CZonotope;
end

% Prediction step
if(flags.pred)
    % Propagate the Polyrelax objects through the system dynamics f
    Zpolyrel = dtsys.f.eval(Xpolyrel,Wpolyrel,u,dtsys.Ts);
else
    Zpolyrel = Xpolyrel;
end
% Get the indexes of the new X (or old X if not prediction)
projindexes = [Zpolyrel.i];


% Update step
if(flags.updt)
    dtsys.g.eval(Zpolyrel,Vpolyrel)==y;
end

% Augmented constrained zonotope Xinput = X x W x V x D, augment only with the nonlinear ones
Xinput = [X_prev;W;V];
nof_inps = Xinput.dim;

% Partially solve A*(x,z)=b in the H-rep and update projindexes
if(OPTIONS.partialsolveAb) % Solve the equality constraints, except for the ones generated by measurement
    [Gh,ch,inputind] = Polyrelax.solveAbTriangPartial(projindexes,nof_inps);
else
    inputind = 1:nof_inps;
end

% Get resulting Hrep and Z, plus projection indexes of the image of f
thisHrep = Polyrelax.Hrep;
thisZ = Polyrelax.Z;
nof_inps = length(inputind);


% Augmented constrained zonotope Xinput x Ztil
X_aug_Z = [projection(Xinput,inputind); CZonotope(thisZ(nof_inps+1:end))];

% Intersection of (X x Z) with the polyhedral relaxation
Xaug_n_P = intersection(X_aug_Z,thisHrep.H,thisHrep.k,thisHrep.A,thisHrep.b);

% Projects the result into the image of f
if(OPTIONS.partialsolveAb)
    Xnew = Gh*Xaug_n_P + ch; 
else
    Xnew = projection(Xaug_n_P,projindexes);
end
cputimes.predupdt = toc;

% Complexity reduction
tic;
Xnew = reduction(Xnew,OPTIONS.ngmax,OPTIONS.ncmax);
cputimes.redu = toc;

% Total computational time
cputimes.total = cputimes.predupdt + cputimes.redu;


end

